"""SQL Generator Agent."""

import json
import logging
import re
from typing import Callable

from meadow.agent.agent import (
    Agent,
    AgentRole,
    ExecutorAgent,
    LLMAgentWithExecutors,
)
from meadow.agent.executor.batch_llm import BatchLLMExecutor
from meadow.agent.executor.reask import ReaskExecutor
from meadow.agent.schema import AgentMessage, ClientMessageRole, ExecutorFunctionInput
from meadow.agent.utils import (
    generate_llm_reply,
    print_message,
)
from meadow.client.client import Client
from meadow.client.schema import LLMConfig
from meadow.database.database import Database
from meadow.database.serializer import serialize_as_list
from meadow.history.message_history import MessageHistory

logger = logging.getLogger(__name__)

DEFAULT_COL_GEN_PROMPT = """You are a helpful data assistant who can give instructions or code for how to generate new columns given an existing user schema.

Given the user's task, you can choose one of three actions to create a new column.

Python: you can generate a new column via Python code.
Direct: you can directly create the new column. This action should be taken if there is fuzziness in the data and not a clean way to generate the column with code.

Please output the new column in one of the following formats.

For Python:
Create a function called `def add_column(df: pd.DataFrame) -> pd.DataFrame` where the `df` is the user's schema. The goal is to add a new column. Output the following for python, starting with the ```python tag.

```python
# Python code to generate the new column including all import statements
def add_column(df: pd.DataFrame) -> pd.DataFrame:
    # Import modules and then add the new column
    import pandas as pd
    ...

    ...
    return df
```

For Direct:
Assume a user has access to the data and needs instructions and examples for how to complete the prompt. Please output a description of how to generate the new column in the following format starting with ``` tag.

```
To generate the new column, follow these steps:
1. Create a new column with name `...
2. ...
...

A sample of the new column is:
...
```

The user's schema is:
{schema}"""

DEFAULT_COL_GEN_DESC = "Generates a new column based on the given user instrution. The input should be a clean description of what the new column should be. The output of this agent is NEVER used as input to another agent."


def update_base_table_with_values(
    table_name: str, column_name: str, values: list, database: Database
) -> str:
    """Update the base table with the new values."""
    new_table_name = f"{table_name}_with_{column_name}"
    temp_table_name = f"_hidden_{table_name}_for_new_value"
    table = database.get_table(table_name)

    # Create a temporary table of table name
    table_sql = (
        f"CREATE TEMPORARY TABLE {temp_table_name} (rn INT, {column_name} VARCHAR)"
    )
    database.create_temp_table(table_sql)

    # Add the new values. ROW_NUMBER() starts at 1 so add 1 to make values match
    values_to_add = [
        {"rn": i + 1, column_name: value} for i, value in enumerate(values)
    ]
    database.insert_values_temp_table(temp_table_name, values_to_add)
    # Create a new view that is old table join with previous view
    view_sql = f"""SELECT {', '.join([c.name for c in table.columns])}, {column_name}
FROM {temp_table_name}
INNER JOIN (
  SELECT ROW_NUMBER() OVER (ORDER BY {', '.join(map(lambda x: x.name, table.columns))}) as rn, * FROM {table_name}
) AS temp1
ON {temp_table_name}.rn = temp1.rn"""
    database.add_view(new_table_name, view_sql)
    database.deprecate_table(table_name)
    return new_table_name


def execute_python_column(
    input: ExecutorFunctionInput,
) -> AgentMessage:
    """Run the python code and create new table."""
    content = input.messages[-1].content
    error_message = None
    display_content = None
    assert (
        len(input.database.tables) == 1
    ), "Only one table should be in the database for column generation."
    if "```python" in content:
        try:
            content = content.split("```python", 1)[1].strip()
            content = content.split("```", 1)[0].strip()
            # Add a comment to the top of the code to indicate that it was generated by the agent
            # We use this in the direct column parser to know if it already
            # hit this parser
            content = "# Python code generated by agent\n" + content
        except Exception:
            error_message = "Python code must be inside ```python...``` tags."
        if not error_message:
            first_real_line = [
                line
                for line in content.split("\n")
                if line.strip() and not line.strip().startswith("#")
            ][0]
            if not first_real_line.strip().startswith("def add_column"):
                error_message = (
                    "Python code must begin by ```python\ndef add_column(...)\n...```"
                )
        if not error_message:
            try:
                base_columns = [c.name for c in input.database.tables[0].columns]
                df = input.database.run_sql_to_df(
                    f"SELECT * FROM {input.database.tables[0].name} ORDER BY {', '.join(base_columns)}"
                )
                # The execution code adds imports inside the function so that code can run.
                # However, I use pd.DataFrame in the type of the function signature. So I
                # readd the import pandas here to make types works.
                full_python_to_execute = f"import pandas as pd\n{content}"
                try:
                    exec(full_python_to_execute)
                except Exception as e:
                    error_message = f"An error occurred while running the code: {e}"
                if not error_message:
                    if "add_column" in locals():
                        # Apply the function to the DataFrame
                        df = eval("add_column(df)")
                    else:
                        error_message = (
                            "Function `add_column` must be defined and callable."
                        )
                if not error_message:
                    if set(df.columns) == set(base_columns):
                        error_message = "No new column was added. Please make sure the new column has a different name."
                if not error_message:
                    new_column_name = list(set(df.columns) - set(base_columns))[0]
                    new_values = df[new_column_name].tolist()
                    update_base_table_with_values(
                        input.database.tables[0].name,
                        new_column_name,
                        new_values,
                        input.database,
                    )
            except Exception as e:
                error_message = f"Error in Python code: {e}"
    if error_message:
        print("ERROR MESSAGE", error_message)
        print("****")
        print("****")
        print("****")
        return AgentMessage(
            content=error_message,
            requires_response=True,
            sending_agent=input.agent_name,
        )
    else:
        return AgentMessage(
            content=content,
            display_content=display_content,
            sending_agent=input.agent_name,
        )


def parse_direct_column(
    input: ExecutorFunctionInput,
) -> AgentMessage:
    content = input.messages[-1].content
    if "```python" not in content and "# Python code generated by agent" not in content:
        return AgentMessage(
            content='Please output the new column value for the input of {input_val}. Output in exactly the format: ```json\n{{"new_column_name": "new_column_value"}}\n```',
            requires_response=True,
            sending_agent=input.agent_name,
        )
    else:
        final_table = input.database.tables[0].name
        display_content = (
            "Here is the final agumented output:\n\n"
            + input.database.run_sql_to_df(
                f"SELECT * FROM {final_table} LIMIT 5"
            ).to_csv(index=False, sep="|")
        )
        return AgentMessage(
            content=content,
            display_content=display_content,
            sending_agent=input.agent_name,
        )


def add_direct_column(
    input: ExecutorFunctionInput,
) -> AgentMessage:
    """Take the output of all the values and create view."""
    assert (
        len(input.database.tables) == 1
    ), "Only one table should be in the database for column generation."
    content = input.messages[-1].content
    table_name = input.database.tables[0].name
    values_as_list_of_dict_str: list[str] = json.loads(content)
    values_as_list_of_dict: list[dict] = [
        json.loads(re.match(r"```json\n(.*)\n```", val, re.DOTALL).group(1))
        for val in values_as_list_of_dict_str
    ]
    values = [list(v.values())[0] for v in values_as_list_of_dict]
    column_name = list(values_as_list_of_dict[0].keys())[0]

    update_base_table_with_values(table_name, column_name, values, input.database)
    final_table = input.database.tables[0].name
    display_content = (
        "Here is the final agumented output:\n\n"
        + input.database.run_sql_to_df(f"SELECT * FROM {final_table} LIMIT 5").to_csv(
            index=False, sep="|"
        )
    )
    return AgentMessage(
        content=content,
        display_content=display_content,
        sending_agent=input.agent_name,
    )


class ColumnGeneratorAgent(LLMAgentWithExecutors):
    """Agent that generates new columns."""

    def __init__(
        self,
        client: Client,
        llm_config: LLMConfig,
        database: Database,
        executors: list[ExecutorAgent] = None,
        name: str = "ColumnGenerator",
        description: str = DEFAULT_COL_GEN_DESC,
        system_prompt: str = DEFAULT_COL_GEN_PROMPT,
        overwrite_cache: bool = False,
        silent: bool = True,
        llm_callback: Callable = None,
    ):
        """Initialize the SQL generator agent."""
        self._client = client
        self._llm_config = llm_config
        self._database = database
        self._executors = executors
        self._name = name
        self._description = description
        self._system_prompt = system_prompt
        self._overwrite_cache = overwrite_cache
        self._llm_callback = llm_callback
        self._silent = silent
        self._messages = MessageHistory()
        self._role = AgentRole.TASK_HANDLER

        if self._executors is None:
            self._executors = [
                ReaskExecutor(
                    client=self._client,
                    llm_config=self._llm_config,
                    database=self._database,
                    execution_func=execute_python_column,
                    llm_callback=self._llm_callback,
                ),
                BatchLLMExecutor(
                    client=self._client,
                    llm_config=self._llm_config,
                    database=self._database,
                    execution_func=parse_direct_column,
                    executors=[
                        ReaskExecutor(
                            client=self._client,
                            llm_config=self._llm_config,
                            database=self._database,
                            execution_func=add_direct_column,
                            llm_callback=self._llm_callback,
                        )
                    ],
                    llm_callback=self._llm_callback,
                ),
            ]

    @property
    def name(self) -> str:
        """Get the name of the agent."""
        return self._name

    @property
    def description(self) -> str:
        """Get the description of the agent."""
        return self._description

    @property
    def llm_client(self) -> Client:
        """The LLM client of this agent."""
        return self._client

    @property
    def database(self) -> Database:
        """The database used by the agent."""
        return self._database

    @property
    def system_message(self) -> str:
        """Get the system message."""
        assert (
            len(self.database.tables) == 1
        ), "Only one table should be in the database for column generation."
        serialized_schema = serialize_as_list(self.database.tables[:1])
        return self._system_prompt.format(
            schema=serialized_schema,
        )

    def set_chat_role(self, role: AgentRole) -> None:
        """Set the chat role of the agent.

        Only used for agents that have executors."""
        self._role = role

    @property
    def executors(self) -> list[ExecutorAgent] | None:
        """The executor agents that should be used by this agent."""
        return self._executors

    def get_messages(self, chat_agent: "Agent") -> list[AgentMessage]:
        """Get the messages between self and the chat_agent."""
        return self._messages.get_messages(chat_agent)

    def add_to_messages(
        self, chat_agent: "Agent", messages: list[AgentMessage]
    ) -> None:
        """Add chat messages between self and chat_agent.

        Used when starting hierarchical chats and historical messages
        need to be passed to the agent.
        """
        self._messages.copy_messages_from(chat_agent, messages)

    async def send(
        self,
        message: AgentMessage,
        recipient: Agent,
    ) -> None:
        """Send a message to another agent."""
        if not message:
            raise ValueError("Message is empty")
        self._messages.add_message(
            agent=recipient, agent_role=ClientMessageRole.SENDER, message=message
        )
        await recipient.receive(message, self)

    async def receive(
        self,
        message: AgentMessage,
        sender: Agent,
    ) -> None:
        """Receive a message from another agent."""
        if not self._silent:
            print_message(
                message,
                from_agent=sender.name,
                to_agent=self.name,
            )
        self._messages.add_message(
            agent=sender, agent_role=ClientMessageRole.RECEIVER, message=message
        )

        reply = await self.generate_reply(
            messages=self._messages.get_messages(sender), sender=sender
        )
        await self.send(reply, sender)

    async def generate_reply(
        self,
        messages: list[AgentMessage],
        sender: Agent,
    ) -> AgentMessage:
        """Generate a reply."""
        chat_response = await generate_llm_reply(
            client=self.llm_client,
            messages=messages,
            tools=[],
            system_message=AgentMessage(
                agent_role=ClientMessageRole.SYSTEM,
                content=self.system_message,
                sending_agent=self.name,
            ),
            llm_config=self._llm_config,
            llm_callback=self._llm_callback,
            overwrite_cache=self._overwrite_cache,
        )
        content = chat_response.choices[0].message.content
        # for msg in messages:
        #     print(msg.content)
        #     print("----")
        print("CONTENT COLUMN GEN", content)

        return AgentMessage(
            content=content,
            sending_agent=self.name,
            requires_execution=True,
        )
